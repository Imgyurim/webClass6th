(this.webpackJsonpwaffle=this.webpackJsonpwaffle||[]).push([[79],{1216:function(y,D,t){"use strict";(function(d){t.d(D,"a",function(){return v});var l=t(0),g=t.n(l),u=t(1208),p=t(1),O=t.n(p),h=t(611);function f(I,b){if(I==null)return{};var E=n(I,b),P,m;if(Object.getOwnPropertySymbols){var j=Object.getOwnPropertySymbols(I);for(m=0;m<j.length;m++)P=j[m],!(b.indexOf(P)>=0)&&Object.prototype.propertyIsEnumerable.call(I,P)&&(E[P]=I[P])}return E}function n(I,b){if(I==null)return{};var E={},P=Object.keys(I),m,j;for(j=0;j<P.length;j++)m=P[j],!(b.indexOf(m)>=0)&&(E[m]=I[m]);return E}let o=0;const s=Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");var v=Object(p.memo)(function(b){var{children:E}=b,P=f(b,["children"]);const[m,j]=M(P);return Object(p.useEffect)(()=>{if(j){const C=w();return++o,()=>{--o===0&&(C[s]=null)}}},[]),Object(l.jsx)(h.a.Provider,{value:m,children:E})});function M(I){if("manager"in I)return[{dragDropManager:I.manager},!1];const b=T(I.backend,I.context,I.options,I.debugMode),E=!I.context;return[b,E]}function T(I,b=w(),E,P){const m=b;return m[s]||(m[s]={dragDropManager:Object(u.a)(I,b,E,P)}),m[s]}function w(){return typeof d!="undefined"?d:window}}).call(this,t(126))},1217:function(y,D,t){"use strict";t.d(D,"b",function(){return d}),t.d(D,"a",function(){return l});function d(g,u,p){const O=p.getRegistry(),h=O.addTarget(g,u);return[h,()=>O.removeTarget(h)]}function l(g,u,p){const O=p.getRegistry(),h=O.addSource(g,u);return[h,()=>O.removeSource(h)]}},1220:function(y,D,t){"use strict";t.d(D,"a",function(){return j});var d=t(545),l=t(515),g=t(1);function u(C){return Object(g.useMemo)(()=>C.hooks.dropTarget(),[C])}var p=t(414),O=t(415),h=t(516);class f{get connectTarget(){return this.dropTarget}reconnect(){const a=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();a&&this.disconnectDropTarget();const r=this.dropTarget;if(this.handlerId){if(!r){this.lastConnectedDropTarget=r;return}a&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=r,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,r,this.dropTargetOptions))}}receiveHandlerId(a){a!==this.handlerId&&(this.handlerId=a,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(a){this.dropTargetOptionsInternal=a}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!Object(p.a)(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(a){this.hooks=Object(h.a)({dropTarget:(r,e)=>{this.clearDropTarget(),this.dropTargetOptions=e,Object(O.a)(r)?this.dropTargetRef=r:this.dropTargetNode=r,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=a}}var n=t(176),o=t(159);function s(C){const a=Object(n.a)(),r=Object(g.useMemo)(()=>new f(a.getBackend()),[a]);return Object(o.a)(()=>(r.dropTargetOptions=C||null,r.reconnect(),()=>r.disconnectDropTarget()),[C]),r}var v=t(47);let M=!1;class T{receiveHandlerId(a){this.targetId=a}getHandlerId(){return this.targetId}subscribeToStateChange(a,r){return this.internalMonitor.subscribeToStateChange(a,r)}canDrop(){if(!this.targetId)return!1;Object(v.a)(!M,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return M=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{M=!1}}isOver(a){return this.targetId?this.internalMonitor.isOverTarget(this.targetId,a):!1}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(a){this.targetId=null,this.internalMonitor=a.getMonitor()}}function w(){const C=Object(n.a)();return Object(g.useMemo)(()=>new T(C),[C])}var I=t(1217);function b(C){const{accept:a}=C;return Object(g.useMemo)(()=>(Object(v.a)(C.accept!=null,"accept must be defined"),Array.isArray(a)?a:[a]),[a])}class E{canDrop(){const a=this.spec,r=this.monitor;return a.canDrop?a.canDrop(r.getItem(),r):!0}hover(){const a=this.spec,r=this.monitor;a.hover&&a.hover(r.getItem(),r)}drop(){const a=this.spec,r=this.monitor;if(a.drop)return a.drop(r.getItem(),r)}constructor(a,r){this.spec=a,this.monitor=r}}function P(C,a){const r=Object(g.useMemo)(()=>new E(C,a),[a]);return Object(g.useEffect)(()=>{r.spec=C},[C]),r}function m(C,a,r){const e=Object(n.a)(),i=P(C,a),c=b(C);Object(o.a)(function(){const[R,x]=Object(I.b)(c,i,e);return a.receiveHandlerId(R),r.receiveHandlerId(R),x},[e,a,i,r,c.map(S=>S.toString()).join("|")])}function j(C,a){const r=Object(l.a)(C,a),e=w(),i=s(r.options);return m(r,e,i),[Object(d.a)(r.collect,e,i),u(i)]}},1221:function(y,D,t){"use strict";t.d(D,"a",function(){return a});var d=t(47),l=t(545),g=t(515),u=t(1);function p(r){return Object(u.useMemo)(()=>r.hooks.dragSource(),[r])}function O(r){return Object(u.useMemo)(()=>r.hooks.dragPreview(),[r])}var h=t(414),f=t(415),n=t(516);class o{receiveHandlerId(e){this.handlerId!==e&&(this.handlerId=e,this.reconnect())}get connectTarget(){return this.dragSource}get dragSourceOptions(){return this.dragSourceOptionsInternal}set dragSourceOptions(e){this.dragSourceOptionsInternal=e}get dragPreviewOptions(){return this.dragPreviewOptionsInternal}set dragPreviewOptions(e){this.dragPreviewOptionsInternal=e}reconnect(){const e=this.reconnectDragSource();this.reconnectDragPreview(e)}reconnectDragSource(){const e=this.dragSource,i=this.didHandlerIdChange()||this.didConnectedDragSourceChange()||this.didDragSourceOptionsChange();return i&&this.disconnectDragSource(),this.handlerId?e?(i&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragSource=e,this.lastConnectedDragSourceOptions=this.dragSourceOptions,this.dragSourceUnsubscribe=this.backend.connectDragSource(this.handlerId,e,this.dragSourceOptions)),i):(this.lastConnectedDragSource=e,i):i}reconnectDragPreview(e=!1){const i=this.dragPreview,c=e||this.didHandlerIdChange()||this.didConnectedDragPreviewChange()||this.didDragPreviewOptionsChange();if(c&&this.disconnectDragPreview(),!!this.handlerId){if(!i){this.lastConnectedDragPreview=i;return}c&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDragPreview=i,this.lastConnectedDragPreviewOptions=this.dragPreviewOptions,this.dragPreviewUnsubscribe=this.backend.connectDragPreview(this.handlerId,i,this.dragPreviewOptions))}}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didConnectedDragSourceChange(){return this.lastConnectedDragSource!==this.dragSource}didConnectedDragPreviewChange(){return this.lastConnectedDragPreview!==this.dragPreview}didDragSourceOptionsChange(){return!Object(h.a)(this.lastConnectedDragSourceOptions,this.dragSourceOptions)}didDragPreviewOptionsChange(){return!Object(h.a)(this.lastConnectedDragPreviewOptions,this.dragPreviewOptions)}disconnectDragSource(){this.dragSourceUnsubscribe&&(this.dragSourceUnsubscribe(),this.dragSourceUnsubscribe=void 0)}disconnectDragPreview(){this.dragPreviewUnsubscribe&&(this.dragPreviewUnsubscribe(),this.dragPreviewUnsubscribe=void 0,this.dragPreviewNode=null,this.dragPreviewRef=null)}get dragSource(){return this.dragSourceNode||this.dragSourceRef&&this.dragSourceRef.current}get dragPreview(){return this.dragPreviewNode||this.dragPreviewRef&&this.dragPreviewRef.current}clearDragSource(){this.dragSourceNode=null,this.dragSourceRef=null}clearDragPreview(){this.dragPreviewNode=null,this.dragPreviewRef=null}constructor(e){this.hooks=Object(n.a)({dragSource:(i,c)=>{this.clearDragSource(),this.dragSourceOptions=c||null,Object(f.a)(i)?this.dragSourceRef=i:this.dragSourceNode=i,this.reconnectDragSource()},dragPreview:(i,c)=>{this.clearDragPreview(),this.dragPreviewOptions=c||null,Object(f.a)(i)?this.dragPreviewRef=i:this.dragPreviewNode=i,this.reconnectDragPreview()}}),this.handlerId=null,this.dragSourceRef=null,this.dragSourceOptionsInternal=null,this.dragPreviewRef=null,this.dragPreviewOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDragSource=null,this.lastConnectedDragSourceOptions=null,this.lastConnectedDragPreview=null,this.lastConnectedDragPreviewOptions=null,this.backend=e}}var s=t(176),v=t(159);function M(r,e){const i=Object(s.a)(),c=Object(u.useMemo)(()=>new o(i.getBackend()),[i]);return Object(v.a)(()=>(c.dragSourceOptions=r||null,c.reconnect(),()=>c.disconnectDragSource()),[c,r]),Object(v.a)(()=>(c.dragPreviewOptions=e||null,c.reconnect(),()=>c.disconnectDragPreview()),[c,e]),c}let T=!1,w=!1;class I{receiveHandlerId(e){this.sourceId=e}getHandlerId(){return this.sourceId}canDrag(){Object(d.a)(!T,"You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return T=!0,this.internalMonitor.canDragSource(this.sourceId)}finally{T=!1}}isDragging(){if(!this.sourceId)return!1;Object(d.a)(!w,"You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");try{return w=!0,this.internalMonitor.isDraggingSource(this.sourceId)}finally{w=!1}}subscribeToStateChange(e,i){return this.internalMonitor.subscribeToStateChange(e,i)}isDraggingSource(e){return this.internalMonitor.isDraggingSource(e)}isOverTarget(e,i){return this.internalMonitor.isOverTarget(e,i)}getTargetIds(){return this.internalMonitor.getTargetIds()}isSourcePublic(){return this.internalMonitor.isSourcePublic()}getSourceId(){return this.internalMonitor.getSourceId()}subscribeToOffsetChange(e){return this.internalMonitor.subscribeToOffsetChange(e)}canDragSource(e){return this.internalMonitor.canDragSource(e)}canDropOnTarget(e){return this.internalMonitor.canDropOnTarget(e)}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(e){this.sourceId=null,this.internalMonitor=e.getMonitor()}}function b(){const r=Object(s.a)();return Object(u.useMemo)(()=>new I(r),[r])}var E=t(1217);class P{beginDrag(){const e=this.spec,i=this.monitor;let c=null;return typeof e.item=="object"?c=e.item:typeof e.item=="function"?c=e.item(i):c={},c!=null?c:null}canDrag(){const e=this.spec,i=this.monitor;return typeof e.canDrag=="boolean"?e.canDrag:typeof e.canDrag=="function"?e.canDrag(i):!0}isDragging(e,i){const c=this.spec,S=this.monitor,{isDragging:R}=c;return R?R(S):i===e.getSourceId()}endDrag(){const e=this.spec,i=this.monitor,c=this.connector,{end:S}=e;S&&S(i.getItem(),i),c.reconnect()}constructor(e,i,c){this.spec=e,this.monitor=i,this.connector=c}}function m(r,e,i){const c=Object(u.useMemo)(()=>new P(r,e,i),[e,i]);return Object(u.useEffect)(()=>{c.spec=r},[r]),c}function j(r){return Object(u.useMemo)(()=>{const e=r.type;return Object(d.a)(e!=null,"spec.type must be defined"),e},[r])}function C(r,e,i){const c=Object(s.a)(),S=m(r,e,i),R=j(r);Object(v.a)(function(){if(R!=null){const[H,L]=Object(E.a)(R,S,c);return e.receiveHandlerId(H),i.receiveHandlerId(H),L}},[c,e,i,S,R])}function a(r,e){const i=Object(g.a)(r,e);Object(d.a)(!i.begin,"useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");const c=b(),S=M(i.options,i.previewOptions);return C(i,c,S),[Object(l.a)(i.collect,c,S),p(S),O(S)]}},159:function(y,D,t){"use strict";t.d(D,"a",function(){return g});var d=t(1),l=t.n(d);const g=typeof window!="undefined"?d.useLayoutEffect:d.useEffect},176:function(y,D,t){"use strict";t.d(D,"a",function(){return p});var d=t(47),l=t(1),g=t.n(l),u=t(611);function p(){const{dragDropManager:O}=Object(l.useContext)(u.a);return Object(d.a)(O!=null,"Expected drag drop context"),O}},414:function(y,D,t){"use strict";t.d(D,"a",function(){return d});function d(l,g,u,p){let O=u?u.call(p,l,g):void 0;if(O!==void 0)return!!O;if(l===g)return!0;if(typeof l!="object"||!l||typeof g!="object"||!g)return!1;const h=Object.keys(l),f=Object.keys(g);if(h.length!==f.length)return!1;const n=Object.prototype.hasOwnProperty.bind(g);for(let o=0;o<h.length;o++){const s=h[o];if(!n(s))return!1;const v=l[s],M=g[s];if(O=u?u.call(p,v,M,s):void 0,O===!1||O===void 0&&v!==M)return!1}return!0}},415:function(y,D,t){"use strict";t.d(D,"a",function(){return d});function d(l){return l!==null&&typeof l=="object"&&Object.prototype.hasOwnProperty.call(l,"current")}},47:function(y,D,t){"use strict";(function(d){t.d(D,"a",function(){return l});function l(u,p,...O){if(g()&&p===void 0)throw new Error("invariant requires an error message argument");if(!u){let h;if(p===void 0)h=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{let f=0;h=new Error(p.replace(/%s/g,function(){return O[f++]})),h.name="Invariant Violation"}throw h.framesToPop=1,h}}function g(){return typeof d!="undefined"&&!0}}).call(this,t(223))},515:function(y,D,t){"use strict";t.d(D,"a",function(){return g});var d=t(1),l=t.n(d);function g(u,p){const O=[...p||[]];return p==null&&typeof u!="function"&&O.push(u),Object(d.useMemo)(()=>typeof u=="function"?u():u,O)}},516:function(y,D,t){"use strict";t.d(D,"a",function(){return O});var d=t(47),l=t(1),g=t.n(l);function u(n){if(typeof n.type=="string")return;const o=n.type.displayName||n.type.name||"the component";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${o} into a <div>, or turn it into a drag source or a drop target itself.`)}function p(n){return(o=null,s=null)=>{if(!Object(l.isValidElement)(o)){const T=o;return n(T,s),T}const v=o;return u(v),f(v,s?T=>n(T,s):n)}}function O(n){const o={};return Object.keys(n).forEach(s=>{const v=n[s];if(s.endsWith("Ref"))o[s]=n[s];else{const M=p(v);o[s]=()=>M}}),o}function h(n,o){typeof n=="function"?n(o):n.current=o}function f(n,o){const s=n.ref;return Object(d.a)(typeof s!="string","Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),s?Object(l.cloneElement)(n,{ref:v=>{h(s,v),h(o,v)}}):Object(l.cloneElement)(n,{ref:o})}},545:function(y,D,t){"use strict";t.d(D,"a",function(){return h});var d=t(763),l=t.n(d),g=t(1),u=t(159);function p(f,n,o){const[s,v]=Object(g.useState)(()=>n(f)),M=Object(g.useCallback)(()=>{const T=n(f);l()(s,T)||(v(T),o&&o())},[s,f,o]);return Object(u.a)(M),[s,M]}function O(f,n,o){const[s,v]=p(f,n,o);return Object(u.a)(function(){const T=f.getHandlerId();if(T!=null)return f.subscribeToStateChange(v,{handlerIds:[T]})},[f,v]),s}function h(f,n,o){return O(n,f||(()=>({})),()=>o.reconnect())}},611:function(y,D,t){"use strict";t.d(D,"a",function(){return g});var d=t(1),l=t.n(d);const g=Object(d.createContext)({dragDropManager:void 0})},612:function(y,D,t){"use strict";(function(d){t.d(D,"b",function(){return u}),t.d(D,"a",function(){return O});const l=typeof d!="undefined"?d:self,g=l.MutationObserver||l.WebKitMutationObserver;function u(h){return function(){const n=setTimeout(s,0),o=setInterval(s,50);function s(){clearTimeout(n),clearInterval(o),h()}}}function p(h){let f=1;const n=new g(h),o=document.createTextNode("");return n.observe(o,{characterData:!0}),function(){f=-f,o.data=f}}const O=typeof g=="function"?p:u}).call(this,t(126))},782:function(y,D,t){"use strict";t.d(D,"a",function(){return h});var d=t(612);class l{enqueueTask(n){const{queue:o,requestFlush:s}=this;o.length||(s(),this.flushing=!0),o[o.length]=n}constructor(){this.queue=[],this.pendingErrors=[],this.flushing=!1,this.index=0,this.capacity=1024,this.flush=()=>{const{queue:n}=this;for(;this.index<n.length;){const o=this.index;if(this.index++,n[o].call(),this.index>this.capacity){for(let s=0,v=n.length-this.index;s<v;s++)n[s]=n[s+this.index];n.length-=this.index,this.index=0}}n.length=0,this.index=0,this.flushing=!1},this.registerPendingError=n=>{this.pendingErrors.push(n),this.requestErrorThrow()},this.requestFlush=Object(d.a)(this.flush),this.requestErrorThrow=Object(d.b)(()=>{if(this.pendingErrors.length)throw this.pendingErrors.shift()})}}class g{call(){try{this.task&&this.task()}catch(n){this.onError(n)}finally{this.task=null,this.release(this)}}constructor(n,o){this.onError=n,this.release=o,this.task=null}}class u{create(n){const o=this.freeTasks,s=o.length?o.pop():new g(this.onError,v=>o[o.length]=v);return s.task=n,s}constructor(n){this.onError=n,this.freeTasks=[]}}const p=new l,O=new u(p.registerPendingError);function h(f){p.enqueueTask(O.create(f))}}}]);
